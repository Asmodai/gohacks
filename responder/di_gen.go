// Code generated by digen; DO NOT EDIT.

package responder

import (
	"context"

	contextdi "github.com/Asmodai/gohacks/contextdi"
	errors "gitlab.com/tozd/go/errors"
)

// --- ResponderChain ---

// Key used to store the instance in the context's user value.
const ContextKeyResponderChain = "gohacks/responder@v1"

// Signalled if the instance associated with the context key is not of
// type *Chain.
var ErrValueNotResponderChain = errors.Base("value is not *Chain")

// Set ResponderChain stores the instance in the context map.
func SetResponderChain(ctx context.Context, inst *Chain) (context.Context, error) {
	val, err := contextdi.PutToContext(ctx, ContextKeyResponderChain, inst)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return val, nil
}

// Get the logger from the given context.
//
// Will return ErrValueNotResponderChain if the value in the context is not of type
// *Chain.
func GetResponderChain(ctx context.Context) (*Chain, error) {
	var zero *Chain

	val, err := contextdi.GetFromContext(ctx, ContextKeyResponderChain)
	if err != nil {
		return zero, errors.WithStack(err)
	}

	inst, ok := val.(*Chain)
	if !ok {
		return zero, errors.WithStack(ErrValueNotResponderChain)
	}

	return inst, nil
}

// Attempt to get the instance from the given context.  Panics if the
// operation fails.
func MustGetResponderChain(ctx context.Context) *Chain {
	inst, err := GetResponderChain(ctx)

	if err != nil {
		panic(errors.WithMessage(err, "ResponderChain missing in context"))
	}

	return inst
}

// TryGetResponderChain returns the instance and true if present and typed.
func TryGetResponderChain(ctx context.Context) (*Chain, bool) {
	var zero *Chain

	val, err := contextdi.GetFromContext(ctx, ContextKeyResponderChain)
	if err != nil {
		return zero, false
	}

	inst, ok := val.(*Chain)
	if !ok {
		return zero, false
	}

	return inst, true
}

// FromResponderChain returns the instance or the fallback.
func FromResponderChain(ctx context.Context) *Chain {
	if v, ok := TryGetResponderChain(ctx); ok {
		return v
	}

	return NewChain("unnamed")
}

// WithResponderChain calls fn with the instance or fallback.
func WithResponderChain(ctx context.Context, fn func(*Chain)) {
	fn(FromResponderChain(ctx))
}

// SetResponderChainIfAbsent sets only if not already present.
func SetResponderChainIfAbsent(ctx context.Context, inst *Chain) (context.Context, error) {
	if _, ok := TryGetResponderChain(ctx); ok {
		return ctx, nil
	}

	return SetResponderChain(ctx, inst)
}

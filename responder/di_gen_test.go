// Code generated by digen; DO NOT EDIT.

package responder

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"testing"
)

// --- ResponderChain ---

func TestResponderChainDI(t *testing.T) {
	t.Run("SetResponderChain", func(t *testing.T) {
		inst := NewChain("unnamed")
		_, err := SetResponderChain(context.Background(), inst)
		if err != nil {
			t.Fatalf("Unexpected error: %#v", err)
		}
	})

	t.Run("GetResponderChain", func(t *testing.T) {
		inst := NewChain("unnamed")
		ctx, err := SetResponderChain(context.Background(), inst)
		if err != nil {
			t.Fatalf("Unexpected error: %#v", err)
		}

		res, err := GetResponderChain(ctx)
		if err != nil {
			t.Fatalf("Unexpected error: %#v", err)
		}

		if res != inst {
			t.Errorf("Unexpected result: %#v ", res)
		}
	})

	t.Run("MustGetResponderChain", func(t *testing.T) {
		t.Run("Panic when missing", func(t *testing.T) {
			ctx := context.Background()
			panicMsg := "ResponderChain missing in context"

			defer func() {
				if r := recover(); r == nil {
					t.Fatalf("expected panic, got none")
				} else {
					// Panic value is an error from
					// errors.WithMessage; check the text.
					msg := fmt.Sprint(r)
					if !strings.Contains(msg, panicMsg) {
						t.Fatalf("panic = %q, want %q",
							msg,
							panicMsg)
					}
				}
			}()

			_ = MustGetResponderChain(ctx) // should panic
		})

		t.Run("No panic when present", func(t *testing.T) {
			ctx, err := SetResponderChain(context.Background(), NewChain("unnamed"))
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			defer func() {
				if r := recover(); r != nil {
					t.Fatalf("Unexpected panic: %v", r)
				}
			}()

			got := MustGetResponderChain(ctx)
			if got == nil {
				t.Fatal("Got nil instance")
			}
		})
	})

	t.Run("TryGetResponderChain", func(t *testing.T) {
		var zero *Chain

		t.Run("Returns valid when present", func(t *testing.T) {
			ctx, err := SetResponderChain(context.Background(), NewChain("unnamed"))
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			val, ok := TryGetResponderChain(ctx)

			if !ok {
				t.Error("Expected true")
			}

			if val == zero {
				t.Errorf("Expected value")
			}
		})

		t.Run("Returns zero when not present", func(t *testing.T) {
			val, ok := TryGetResponderChain(context.Background())

			if ok {
				t.Error("Expected false")
			}

			if val != zero {
				t.Errorf("Expected zero got %#v", val)
			}
		})
	})

	t.Run("FromResponderChain", func(t *testing.T) {
		rtype := reflect.TypeOf(NewChain("unnamed"))

		t.Run("Returns instance when present", func(t *testing.T) {
			inst := NewChain("unnamed")

			ctx, err := SetResponderChain(context.Background(), inst)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			val := FromResponderChain(ctx)
			if val != inst {
				t.Fatalf("Unexpected value: %#v", val)
			}
		})

		t.Run("Returns fallback when not present", func(t *testing.T) {
			val := FromResponderChain(context.Background())

			if reflect.TypeOf(val) != rtype {
				t.Fatalf("Unexpected value: %#v", val)
			}
		})
	})

	t.Run("WithResponderChain", func(t *testing.T) {
		rtype := reflect.TypeOf(NewChain("unnamed"))

		t.Run("Returns instance when present", func(t *testing.T) {
			inst := NewChain("unnamed")

			ctx, err := SetResponderChain(context.Background(), inst)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			WithResponderChain(ctx, func(obj *Chain) {
				if obj != inst {
					t.Fatalf("Unexpected value: %#v", obj)
				}
			})
		})

		t.Run("Returns fallback when not present", func(t *testing.T) {
			WithResponderChain(context.Background(), func(obj *Chain) {
				if reflect.TypeOf(obj) != rtype {
					t.Fatalf("Unexpected value: %#v", obj)
				}
			})
		})
	})
}

// -*- Mode: Go; auto-fill: t; fill-column: 78; -*-
//
// SPDX-License-Identifier: MIT
//
// tmpl_code.go --- Code template for DI.
//
// Copyright (c) 2025 Paul Ward <paul@lisphacker.uk>
//
// Author:     Paul Ward <paul@lisphacker.uk>
// Maintainer: Paul Ward <paul@lisphacker.uk>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// * Comments:

// * Package:

package main

// * Imports:

import "text/template"

// * Variables:

//nolint:gochecknoglobals
var (
	codeTempl = template.Must(template.New("di").Parse(`// Code generated by digen; DO NOT EDIT.

package {{.PkgName}}

import (
	"context"
	{{- range $alias, $path := .Imports }}
	{{- if eq $alias "_" }}
	_ "{{ $path }}"
	{{- else if eq $alias "" }}
	"{{ $path }}"
	{{- else }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
	{{- end }}
)

{{- range .Specs }}

// --- {{ .Basename }} ---

// Key used to store the instance in the context's user value.
const ContextKey{{ .Basename }} = "{{ .Key }}"

// Signalled if the instance associated with the context key is not of
// type {{ .TypeExpr }}.
var ErrValueNot{{ .Basename }} = errors.Base("value is not {{ .TypeExpr }}")

// Set {{ .Basename }} stores the instance in the context map.
func Set{{ .Basename }}(ctx context.Context, inst {{ .TypeExpr }}) (context.Context, error) {
	val, err := contextdi.PutToContext(ctx, ContextKey{{ .Basename }}, inst)
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return val, nil
}

// Get the logger from the given context.
//
// Will return ErrValueNot{{ .Basename }} if the value in the context is not of type
// {{ .TypeExpr }}.
func Get{{ .Basename }}(ctx context.Context) ({{ .TypeExpr }}, error) {
	var zero {{ .TypeExpr }}

	val, err := contextdi.GetFromContext(ctx, ContextKey{{ .Basename }})
	if err != nil {
		return zero, errors.WithStack(err)
	}

	inst, ok := val.({{ .TypeExpr }})
	if !ok {
		return zero, errors.WithStack(ErrValueNot{{ .Basename }})
	}

	return inst, nil
}

// Attempt to get the instance from the given context.  Panics if the
// operation fails.
func MustGet{{ .Basename }}(ctx context.Context) {{ .TypeExpr }} {
	inst, err := Get{{ .Basename }}(ctx)

	if err != nil {
		panic(errors.WithMessage(err, "{{ .Basename }} missing in context"))
	}

	return inst
}

// TryGet{{ .Basename }} returns the instance and true if present and typed.
func TryGet{{ .Basename }}(ctx context.Context) ({{ .TypeExpr }}, bool) {
	var zero {{ .TypeExpr }}

	val, err := contextdi.GetFromContext(ctx, ContextKey{{ .Basename }})
	if err != nil {
		return zero, false
	}

	inst, ok := val.({{ .TypeExpr }})
	if !ok {
		return zero, false
	}

	return inst, true
}

// From{{ .Basename }} returns the instance or the fallback.
func From{{ .Basename }}(ctx context.Context) {{ .TypeExpr }} {
	if v, ok := TryGet{{ .Basename }}(ctx); ok {
		return v
	}

	return {{ .Fallback }}
}

// With{{ .Basename }} calls fn with the instance or fallback.
func With{{ .Basename }}(ctx context.Context, fn func({{ .TypeExpr }})) {
	fn(From{{ .Basename }}(ctx))
}

// Set{{ .Basename }}IfAbsent sets only if not already present.
func Set{{ .Basename }}IfAbsent(ctx context.Context, inst {{ .TypeExpr }}) (context.Context, error) {
	if _, ok := TryGet{{ .Basename }}(ctx); ok {
		return ctx, nil
	}

	return Set{{ .Basename }}(ctx, inst)
}

{{- end }}
`))
)

// * tmpl_code.go ends here.

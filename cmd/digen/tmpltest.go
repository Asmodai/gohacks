// -*- Mode: Go; auto-fill: t; fill-column: 78; -*-
//
// SPDX-License-Identifier: MIT
//
// tmpl_test.go --- Unit test template.
//
// Copyright (c) 2025 Paul Ward <paul@lisphacker.uk>
//
// Author:     Paul Ward <paul@lisphacker.uk>
// Maintainer: Paul Ward <paul@lisphacker.uk>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// * Comments:

// * Package:

package main

// * Imports:

import "text/template"

// * Variables:

//nolint:gochecknoglobals
var (
	testTempl = template.Must(template.New("test").Parse(`// Code generated by digen; DO NOT EDIT.

package {{ .PkgName }}

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"testing"

	{{- range $alias, $path := .Imports }}
	{{- if eq $alias "_" }}
	_ "{{ $path }}"
	{{- else if eq $alias "" }}
	"{{ $path }}"
	{{- else }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
	{{- end }}
)

{{- range .Specs }}

// --- {{ .Basename }} ---

func Test{{ .Basename }}DI(t *testing.T) {
	t.Run("Set{{ .Basename }}", func(t *testing.T) {
		inst:={{ .Fallback }}
		_, err := Set{{ .Basename }}(context.Background(), inst)
		if err != nil {
			t.Fatalf("Unexpected error: %#v", err)
		}
	})

	t.Run("Get{{ .Basename }}", func(t *testing.T) {
		inst := {{ .Fallback }}
		ctx, err := Set{{ .Basename }}(context.Background(), inst)
		if err != nil {
			t.Fatalf("Unexpected error: %#v", err)
		}

		res, err := Get{{ .Basename }}(ctx)
		if err != nil {
			t.Fatalf("Unexpected error: %#v", err)
		}

		if res != inst {
			t.Errorf("Unexpected result: %#v ", res)
		}
	})

	t.Run("MustGet{{ .Basename }}", func(t *testing.T) {
		t.Run("Panic when missing", func(t *testing.T) {
			ctx := context.Background()
			panicMsg := "{{ .Basename }} missing in context"

			defer func() {
				if r := recover(); r == nil {
					t.Fatalf("expected panic, got none")
				} else {
					// Panic value is an error from
					// errors.WithMessage; check the text.
					msg := fmt.Sprint(r)
					if !strings.Contains(msg, panicMsg) {
						t.Fatalf("panic = %q, want %q",
							msg,
							panicMsg)
					}
				}
			}()

			_ = MustGet{{ .Basename }}(ctx) // should panic
		})

		t.Run("No panic when present", func(t *testing.T) {
			ctx, err := Set{{ .Basename }}(context.Background(), {{ .Fallback }})
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			defer func() {
				if r := recover(); r != nil {
					t.Fatalf("Unexpected panic: %v", r)
				}
			}()

			got := MustGet{{ .Basename }}(ctx)
			if got == nil {
				t.Fatal("Got nil instance")
			}
		})
	})

	t.Run("TryGet{{ .Basename }}", func(t *testing.T) {
		var zero {{ .TypeExpr }}

		t.Run("Returns valid when present", func(t *testing.T) {
			ctx, err := Set{{ .Basename }}(context.Background(), {{ .Fallback }})
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			val, ok := TryGet{{ .Basename }}(ctx)

			if !ok {
				t.Error("Expected true")
			}

			if val == zero {
				t.Errorf("Expected value")
			}
		})

		t.Run("Returns zero when not present", func(t *testing.T) {
			val, ok := TryGet{{ .Basename }}(context.Background())

			if ok {
				t.Error("Expected false")
			}

			if val != zero {
				t.Errorf("Expected zero got %#v", val)
			}
		})
	})

	t.Run("From{{ .Basename }}", func(t *testing.T) {
		rtype := reflect.TypeOf({{ .Fallback }})

		t.Run("Returns instance when present", func(t *testing.T) {
			inst := {{ .Fallback }}

			ctx, err := Set{{ .Basename }}(context.Background(), inst)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			val := From{{ .Basename }}(ctx)
			if val != inst {
				t.Fatalf("Unexpected value: %#v", val)
			}
		})

		t.Run("Returns fallback when not present", func(t *testing.T) {
			val := From{{ .Basename }}(context.Background())

			if reflect.TypeOf(val) != rtype {
				t.Fatalf("Unexpected value: %#v", val)
			}
		})
	})

	t.Run("With{{ .Basename }}", func(t *testing.T) {
		rtype := reflect.TypeOf({{ .Fallback }})

		t.Run("Returns instance when present", func(t *testing.T) {
			inst := {{ .Fallback }}

			ctx, err := Set{{ .Basename }}(context.Background(), inst)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			With{{ .Basename }}(ctx, func(obj {{ .TypeExpr }}) {
				if obj != inst {
					t.Fatalf("Unexpected value: %#v", obj)
				}
			})
		})

		t.Run("Returns fallback when not present", func(t *testing.T) {
			With{{ .Basename }}(context.Background(), func(obj {{ .TypeExpr }}) {
				if reflect.TypeOf(obj) != rtype {
					t.Fatalf("Unexpected value: %#v", obj)
				}
			})
		})
	})
}

{{- end }}
`))
)

// * tmpl_test.go ends here.

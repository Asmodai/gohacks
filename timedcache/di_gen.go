// Code generated by digen; DO NOT EDIT.

package timedcache

import (
	"context"

	contextdi "github.com/Asmodai/gohacks/contextdi"
	errx "github.com/Asmodai/gohacks/errx"
)

// --- TimedCache ---

// Key used to store the instance in the context's user value.
const ContextKeyTimedCache = "gohacks/timedcache@v1"

// Signalled if the instance associated with the context key is not of
// type TimedCache.
var ErrValueNotTimedCache = errx.Base("value is not TimedCache")

// Set TimedCache stores the instance in the context map.
func SetTimedCache(ctx context.Context, inst TimedCache) (context.Context, error) {
	val, err := contextdi.PutToContext(ctx, ContextKeyTimedCache, inst)
	if err != nil {
		return nil, errx.WithStack(err)
	}

	return val, nil
}

// Get the instance from the given context.
//
// Will return ErrValueNotTimedCache if the value in the context is not of type
// TimedCache.
func GetTimedCache(ctx context.Context) (TimedCache, error) {
	var zero TimedCache

	val, err := contextdi.GetFromContext(ctx, ContextKeyTimedCache)
	if err != nil {
		return zero, errx.WithStack(err)
	}

	inst, ok := val.(TimedCache)
	if !ok {
		return zero, errx.WithStack(ErrValueNotTimedCache)
	}

	return inst, nil
}

// Attempt to get the instance from the given context.  Panics if the
// operation fails.
func MustGetTimedCache(ctx context.Context) TimedCache {
	inst, err := GetTimedCache(ctx)

	if err != nil {
		panic(errx.WithMessage(err, "TimedCache missing in context"))
	}

	return inst
}

// TryGetTimedCache returns the instance and true if present and typed.
func TryGetTimedCache(ctx context.Context) (TimedCache, bool) {
	var zero TimedCache

	val, err := contextdi.GetFromContext(ctx, ContextKeyTimedCache)
	if err != nil {
		return zero, false
	}

	inst, ok := val.(TimedCache)
	if !ok {
		return zero, false
	}

	return inst, true
}

// FromTimedCache returns the instance or the fallback.
func FromTimedCache(ctx context.Context) TimedCache {
	if v, ok := TryGetTimedCache(ctx); ok {
		return v
	}

	return NewDefault()
}

// WithTimedCache calls fn with the instance or fallback.
func WithTimedCache(ctx context.Context, fn func(TimedCache)) {
	fn(FromTimedCache(ctx))
}

// SetTimedCacheIfAbsent sets only if not already present.
func SetTimedCacheIfAbsent(ctx context.Context, inst TimedCache) (context.Context, error) {
	if _, ok := TryGetTimedCache(ctx); ok {
		return ctx, nil
	}

	return SetTimedCache(ctx, inst)
}
